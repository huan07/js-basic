<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>21.1</title>
</head>
<body>

<script>
    function createXHR(){
        if (typeof XMLHttpRequest !== 'undefined') {
            // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
            return new XMLHttpRequest();
        } else if (typeof ActiveXObject !== 'undefined') { // 更复杂的过程 to add
            // IE6, IE5 浏览器执行代码
            return new ActiveXObject('Microsoft.XMLHTTP');
        } else {
            throw new Error('No XHR object available');
        }
    }
</script>

<script>
    // Ajax 同步请求：js代码等到服务器相应之后再继续执行
    // URL与当前页面是同一个域、相同的端口、协议（同源策略）；
    // 同步不需要 onreadystatechange函数
    var xhr = new createXHR();
    xhr.open('get', 'ajax_info.json', false); // 启动请求以备发送
    xhr.send(null);
    console.log('同步请求 => ', xhr);
</script>

<script>
    var xhr = new createXHR();
    xhr.open('get', 'ajax_info.json?t=' + Math.random(), false); // 避免304，浏览器的缓存数据
    xhr.send(null);
    console.log('同步请求2 => ', xhr);
</script>


<script>
    // Ajax 异步请求：js继续执行不必等待响应
    var xhr2 = new createXHR();

    xhr2.onreadystatechange = function(){

        if (xhr2.readyState === 4) {
            console.log(this, xhr2, this === xhr2); // 浏览器兼容性

            var myheader = xhr2.getResponseHeader('myheader'); // 设置成功，然而并没有取到值
            var allHeader = xhr2.getAllResponseHeaders();
            console.log(myheader);
            console.log(allHeader);

            if ((xhr2.status >= 200 && xhr2.status < 300) || xhr2.status === 304) {
                console.log(xhr2.response, xhr2.responseText);
            } else {
                console.log('request was unsuccessful' + xhr2.status)
            }
        }
    };

    xhr2.open('get', 'ajax_info.json', true);
    // https://www.reddit.com/r/reactjs.json

    xhr2.setRequestHeader('Accept', 'application/json');
    xhr2.setRequestHeader('Content-type', 'application/json');
    xhr2.setRequestHeader('MyHeader', 'MyValue');

    xhr2.send(null);
</script>

<script>
    // get  向服务器查询某些信息  URL末尾的查询字符串必须经过编码(name,value)
    // post 向服务器发送应该被保存的数据

    // 区别：
    // 查询信息name,value经过编码后 紧跟在请求的URL后面，有数量限制；暴露在外面不安全；发送相同的数据，get请求的速度快；
    // post请求消耗的资源多；
</script>

</body>
</html>