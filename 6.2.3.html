<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>6.2.3原型模式</title>
</head>
<body>
<script>
    // prototype  每个函数都有，是一个指针，指向对象（其用途：包含特定类型的所有实例 共享的属性和方法）
    function Person(){ // 实例属性，不可以共享
    }
    Person.prototype.name = 'person11_person12'; // 原型属性，共享
    Person.prototype.age = 30;
    Person.prototype.job = 'job';
    Person.prototype.sayName = function(){
        return this.name + '-' + this.age + '-' + this.job;
    };

    var person11 = new Person();
    var person12 = new Person();
    console.log('原型对象共享的方法======', person11.sayName, person11.sayName === person12.sayName);

    // 原型对象的属性constructor ！！！！！！最初包含，共享的！！！！！！！！！！！！！！！！！！！！！！！！！！
    console.log('原型对象constructor属性========', Person.prototype.constructor, Person.prototype.constructor === Person);

    // 实例对象的内部属性 [[Prototype]] __proto__  指向构造函数的原型对象 ！！！！！！！！！！！！！！！！！！
    console.log('实例对象的内部属性__proto__=====', person11.__proto__, person11.__proto__ === Person.prototype);

    // isPrototypeof  原型对象 是否是 实例对象的原型！！！！！！！！！！！！！！！！！！！！！！
    console.log('isPrototypeOf=====, ', Person.prototype.isPrototypeOf(person11), Person.prototype.isPrototypeOf(person12));

    // getPrototypeOf  返回实例对象的 原型对象！！！！！！！！！！！！！！！！！！！！！！
    console.log('getPrototypeOf, ===', Object.getPrototypeOf(person11), Object.getPrototypeOf(person11) === Person.prototype);
    console.log('getPrototypeOf, ===', Object.getPrototypeOf(person11).name, Object.getPrototypeOf(person11).age);


    // 先搜索对象实例，再搜索原型  属性
    // 不能通过对象实例重写原型的值
    // delete删除 对象实例 属性 ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    // hasOwnProperty 属性存在 对象实例  ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    person11.name = 'person11';
    console.log('hasOwnProperty,===== ', person11.name, person11.hasOwnProperty('name'), person12.name, person12.hasOwnProperty('name'));
    delete person11.name;
    console.log(person11.name, person11.hasOwnProperty('name'), person12.name, person12.hasOwnProperty('name'));


    // in,  for in 可枚举的对象实例 + 原型 ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    console.log('in   for in, ===== ', 'name' in person11);
    person11.name = 'person11';
    console.log('name' in person11);

    function hasPrototypeProperty(object, name){ // ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
        return !object.hasOwnProperty(name) && (name in object);   // 不属于实例属性  属于对象属性
    }
    console.log('hasPrototypeProperty, ==== 自定义', hasPrototypeProperty(person11, 'name'), hasPrototypeProperty(person12, 'name'));


    // 浏览器兼容性 to add

    // Object.keys() 可枚举的实例属性 返回数组！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    // Object.getOwnPropertyNames() 所有实例属性 ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    var person13 = new Person();
    person13['name_age'] = 'name_age';
    console.log('Object.keys()！！！！！！！ ', Object.keys(person13), Object.keys(Person.prototype));
    console.log('Object.getOwnPropertyNames() ', Object.getOwnPropertyNames(person13), Object.getOwnPropertyNames(Person.prototype));  // constructor不可枚举


    function People(){

    }
    console.log('重写整个原型对象之前，', JSON.stringify(People.prototype), People.prototype.constructor); // People
    People.prototype = { // 重写整个原型对象
        //  constructor:People, //手动设置 变成可以枚举  不写的话默认值是Object
        name: 'people_name',
        age: 'people_age',
        job: 'people_job',
        sayName: function(){
            console.log(this.name + '-' + this.age);
        }
    };
    console.log('重写整个原型对象之后，', JSON.stringify(People.prototype), People.prototype.constructor); // Object

    var people = new People();
    people['name_job'] = 'name_job';
    console.log(Object.keys(people), Object.keys(People.prototype));
    console.log(Object.getOwnPropertyNames(people), Object.getOwnPropertyNames(People.prototype));


    // 原型的动态性 ！！！！！！！！！！！！！！！！
    var friend = new People();

    People.prototype.sayHi = function(){
        console.log('sayHi //' + this.name + '//' + this.age + '//' + this.job);
    };
    friend.sayHi();

    // 原型的动态性 ！！！！！！！！！！！！！！！！
    // 重写默认的prototype对象， 1.constructor属性变成了新对象的constructor属性（指向Object构造函数）
    // 2.切断了构造函数与最初原型的联系
    function Person(){

    }
    var friend2 = new Person();

    Person.prototype = {
        constructor: Person,
        name: 'nicholas',
        age: 30,
        friend: 'yc',
        sayHi: function(){
            return 'sayHi //' + this.friend;
        }
    };
    // friend2.sayHi(); error


    // 原生对象的原型
    console.log('native prototype, ', Array.prototype, String.prototype)

    // 原型对象的问题
    // 所有实例在默认情况下都将取得相同的属性值   对于包含引用类型值的属性，问题突出！！！！！！！！！！！！！
    function PeopleF(){

    }

    PeopleF.prototype = {
        constructor: PeopleF,
        name: 'name',
        friends: ['friend1', 'friend2', 'friend3'],
        sayName: function(){
            console.log(this.name + '-' + this.friends.length);
        }
    };
    var peopleF = new PeopleF();
    var peopleF2 = new PeopleF();
    peopleF.friends.push('friend4');
    console.log('原型对象的问题, ', peopleF.friends, peopleF2.friends, peopleF.friends === peopleF2.friends);
    peopleF.sayName();  // 原型对象的重写放在实例化后面就会报错

    // 练习题
    function CreatObj(){
        this.name = 'aaa';
        this.price = 'bbb';
    }
    CreatObj.prototype.action = function(){
        console.log('ccc');
    };
    var obj = new CreatObj();
    var str = ' ';
    for (var i in obj) {
        console.log(str += obj[i]);
    }
</script>

</body>
</html>