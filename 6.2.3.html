<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>6.2.3原型模式</title>
</head>
<body>
<script>
    // prototype  每个函数都有，是一个指针，指向对象（其用途：包含特定类型的所有实例 共享的属性和方法）
    function Person(){ // 实例属性、方法，不共享
    }
    Person.prototype.name = 'person11_person12'; // 原型属性、方法，共享
    Person.prototype.age = 30;
    Person.prototype.job = 'job';
    Person.prototype.sayName = function(){
        return this.name + '-' + this.age + '-' + this.job;
    };

    var person11 = new Person();
    person11.name = 'person11';

    var person12 = new Person();
    console.log(person11);
    console.log('原型对象共享的方法 => ', person11.sayName, person11.sayName === person12.sayName);

    // constructor ！！最初包含，共享的
    console.log('实例constructor属性 => ', person11.constructor, person11.constructor === Person);
    console.log(Person.prototype.constructor, Person.prototype.constructor === Person);

    // 实例的内部属性 [[Prototype]] __proto__  指向构造函数的原型
    console.log('__proto__ => ', person11.__proto__, person11.__proto__ === Person.prototype);

    // isPrototypeOf  原型 是否是 实例的原型      继承方法！！
    console.log('isPrototypeOf => ', Person.prototype.isPrototypeOf(person11));

    // getPrototypeOf Object方法  返回实例的 原型
    console.log('getPrototypeOf => ', Object.getPrototypeOf(person11), Object.getPrototypeOf(person11) === Person.prototype);

    // 对象熟悉搜索机制：
    // 先搜索实例属性，找到就返回；否则，继续搜索原型属性；
    // 不能通过实例重写原型的值；

    // hasOwnProperty 是否是 实例属性    继承方法！！
    // delete 删除 实例属性
    person11.name = 'person11'; // 屏蔽原型的属性
    console.log('hasOwnProperty => ', person11.name, person11.hasOwnProperty('name'), person12.name, person12.hasOwnProperty('name'));
    delete person11.name;
    console.log('delete => ', person11.name, person11.hasOwnProperty('name'), person12.name, person12.hasOwnProperty('name'));

    // getOwnPropertyDescriptor  获取对象上属性的描述，
    person11.name = 'person11';
    var instanceDescriptor = Object.getOwnPropertyDescriptor(person11, 'name');
    var prototypeDescriptor = Object.getOwnPropertyDescriptor(Person.prototype, 'name');
    console.log('Object.getOwnPropertyDescriptor => ', instanceDescriptor, prototypeDescriptor);


    // in,  for in 可枚举的属性
    console.log('in   for in => ', 'name' in person11);
    person11.name = 'person11';
    console.log('name' in person11);

    function hasPrototypeProperty(object, name){
        return !object.hasOwnProperty(name) && (name in object);   // 不属于实例属性  属于对象属性
    }
    console.log('hasPrototypeProperty =>', hasPrototypeProperty(person11, 'name'), hasPrototypeProperty(person12, 'name'));


    // 浏览器兼容性 to add

    // Object.keys() 可枚举的实例属性  返回数组
    // Object.getOwnPropertyNames() 所有实例属性  返回数组
    // 原生constructor不可枚举
    var person13 = new Person();
    person13['name_age'] = 'name_age';
    console.log('Object.keys => ', Object.keys(person13), Object.keys(Person.prototype));
    console.log('Object.getOwnPropertyNames => ', Object.getOwnPropertyNames(person13), Object.getOwnPropertyNames(Person.prototype));
</script>

<script>
    function People(){

    }
    console.log('重写整个原型对象之前 => ', People.prototype, People.prototype.constructor); // People
    People.prototype = {
        // constructor:People, // 手动设置变成可以枚举  不写的话默认值是Object
        name: 'people_name',
        age: 'people_age',
        job: 'people_job',
        sayName: function(){
            console.log(this.name + '-' + this.age);
        }
    };
    console.log('重写整个原型对象之后 => ', People.prototype, People.prototype.constructor); // Object

    var people = new People();
    people['name_job'] = 'name_job';
    console.log(Object.keys(people), Object.keys(People.prototype));
    console.log(Object.getOwnPropertyNames(people), Object.getOwnPropertyNames(People.prototype));


    // 原型的动态性 ！！！！！！！！！！！！！！！！
    var friend = new People();

    People.prototype.sayHi = function(){ // 创建实例后添加原型属性方法，实例和原型的松散连接
        console.log('sayHi //' + this.name + '//' + this.age + '//' + this.job);
    };
    friend.sayHi();

    // 原型的动态性 ！！！！！！！！！！！！！！！！
    // 创建实例的情况下 重写默认的prototype对象：1.切断了构造函数与最初原型的联系
    // 实例的指针指向原型，不是构造函数，
    function Person(){

    }
    var friend2 = new Person();

    Person.prototype = { // 创建实例后重写原型对象
        constructor: Person,
        name: 'nicholas',
        age: 30,
        friend: 'yc',
        sayHi: function(){
            return 'sayHi //' + this.friend;
        }
    };
    // friend2.sayHi(); // error


    function XxX(){

    }
    XxX.prototype = {
        constructor: XxX,
        name: 'nicholas',
        age: 30,
        friend: 'yc',
        sayHiWord: function(){
            return 'XxX XxX XxX XxX XxX';
        }
    };

    var xx = new XxX();
    xx.sayHiWord(); // ?????????不管用


    // 原生对象的原型
</script>
<script>
    // 原型对象的问题
    // 所有实例在默认情况下都将取得相同的属性值   对于包含引用类型值的属性，问题突出！！！！！！！！！！！！！
    function Person(){

    }

    Person.prototype = {
        constructor: Person,
        name: 'name',
        friends: ['friend1', 'friend2'],
        sayName: function(){
            console.log(this.name + '-' + this.friends.length);
        }
    };
    var person = new Person();
    var person2 = new Person();
    person2.friends.push('friend3');
    console.log('原型对象的问题 => ', person.friends, person2.friends, person.friends === person2.friends);
    person2.sayName();

    // 练习题
    function CreatObj(){
        this.name = 'aaa';
        this.price = 'bbb';
    }
    CreatObj.prototype.action = function(){
        console.log('ccc');
    };
    var obj = new CreatObj();
    var str = ' ';
    for (var i in obj) {
        str += obj[i];
        console.log(str);
    }
</script>

</body>
</html>