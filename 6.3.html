<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>6.3</title>
</head>
<body>
<script>
    // 原型链实现继承
    // 所有函数的默认原型都是Objece的实例
    // instanceof
    // prototype.isPrototypeOf
    function SuperType() {
        this.property = true;
    }
    SuperType.prototype.getSuperType = function() {
        return this.property;
    };

    function SubType() {
        this.subproperty = false;
    }
    SubType.prototype = new SuperType(); // 继承方式 创建实例来重写原型对象：！！！！！！！！！！！
    SubType.prototype.getSubValue = function() { // 添加方法
        return this.subproperty;
    };
    // 给原型添加的方法要在替换原型的语句之后
    // 不能使用对象字面量创建原型方法，会重写原型链

    var subTypeInstance = new SubType();
    var superTypeInstance = new SuperType();
    console.log(subTypeInstance.getSubValue(), subTypeInstance.getSuperType());
    console.log(superTypeInstance.getSuperType());
    console.log(SubType.prototype.constructor, SuperType, SubType.prototype.constructor === SuperType);


    console.log('Object.prototype=   ', Object.prototype);

    console.log(subTypeInstance instanceof Object);
    console.log(subTypeInstance instanceof SuperType);
    console.log(subTypeInstance instanceof SubType);


    console.log(Object.prototype.isPrototypeOf(subTypeInstance));
    console.log(SuperType.prototype.isPrototypeOf(subTypeInstance));
    console.log(SubType.prototype.isPrototypeOf(subTypeInstance));
</script>

<script>
    // 原型链的继承问题
    // 1.引用类型值的原型属性会被所有实例共享
    // 由1.导致的问题是：原先的实例属性变成了现在的原型属性

    // 2.在创建子类型的实例时，不能向超类型的构造函数传递参数

    function SuperType() {
        this.colors = ['red', 'red2', 'red3'];
    }

    function SubType() {

    }
    SubType.prototype = new SuperType();
    var subTypeInstance = new SubType();
    subTypeInstance.colors.push('red4');
    console.log(subTypeInstance.colors);

    var subTypeInstance2 = new SubType();
    console.log(subTypeInstance2.colors);
</script>

<script>
    // 借用构造函数（伪造对象，经典继承）解决问题1
    function SuperType() {
        this.colors = ['blue', 'blue2', 'blue3'];
    }

    function SubType() {
        // 调用构造函数 实现继承
        SuperType.call(this);
    }

    var subTypeInstance = new SubType();
    subTypeInstance.colors.push('blue4');
    console.log(subTypeInstance.colors);

    var subTypeInstance2 = new SubType();
    console.log(subTypeInstance2.colors);
</script>

<script>
    // 在子类型构造函数中向超类型构造函数传递参数 解决问题2
    function SuperType(name) {
        this.name = name;
    }

    function SubType() {
        // 调用构造函数 实现继承 还可以传参数
        SuperType.call(this, 'ycg');
        this.age = 28;
    }
    var subTypeInstance = new SubType();
    console.log(JSON.stringify(subTypeInstance));
    // 构造函数的问题：无法复用函数
</script>

<script>
    // 组合继承（伪经典继承）
    // 思路：原型链实现对原型属性，方法的继承；借用构造函数实现对实例属性的继承
    function SuperType(name) {
        this.name = name;
        this.colors = ['green', 'green2', 'green3'];
    }
    SuperType.prototype.sayName = function() {
        console.log(this.name);
    };

    function SubType(name, age) {
        // 继承属性
        SuperType.call(this, name);
        this.age = age;
    }
    // 继承方法
    SubType.prototype = new SuperType();
    SubType.prototype.sayAge = function() {
        console.log(this.age);
    };

    var subTypeInstance = new SubType('yh', 29);
    subTypeInstance.colors.push('green4');
    console.log(subTypeInstance);
    subTypeInstance.sayName();
    subTypeInstance.sayAge();


    var subTypeInstance2 = new SubType('yhyh', 2929);
    console.log(subTypeInstance2);
    subTypeInstance2.sayName();
    subTypeInstance2.sayAge();
</script>

</body>
</html>