<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // 工厂模式
    function createPerson(name, age, job) { // 解决了多个相似对象的问题，存在对象识别的问题
        var o = new Object();
        o.name = name;
        o.age = age;
        o.job = job;
        o.sayName = function() {
            console.log(this.name + '-' + this.age);
        };
        return o;
    }

    var person = createPerson('person', 30, 'software engineer');
    var person2 = createPerson('person2', 29, 'a woman');
    person.sayName();
    person2.sayName();
    console.log(person.sayName, person2.sayName, person.sayName === person2.sayName);
</script>

<script>
    // 构造函数模式
    function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function() { // 不同实例上的同名函数是不相等的
            console.log(this.name + '-' + this.age);
        };
    }

    var person3 = new Person('person3', 30, 'software engineer');
    var person4 = new Person('person4', 40, 'a beautifull woman');
    person3.sayName();
    person4.sayName();
    console.log(person3.sayName, person4.sayName, person3.sayName === person4.sayName);

    // new 操作法 经历的4个步骤！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    //（1）创建一个新对象
    //（2）将构造函数的作用域赋给新对象（this指向这个新对象）
    //（3）执行构造函数的代码（为新对象添加属性）
    //（4）返回新对象

    console.log('constructor========', person3.constructor, person4.constructor, Person, person3.constructor === person4.constructor === Person);

    console.log(person3 instanceof Object, person3 instanceof Person, person4 instanceof Object, person4 instanceof Person);

    // 构造函数与普通函数的区别：调用方式不一样

    // Person的调用方式！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！call
    // 1.
    var person5 = new Person('person5', 50, 'a beautifull woman');
    person5.sayName();

    // 2.
    Person('person6', 60, 'a beautifull woman too'); // 添加到Window
    window.sayName();

    // 3.
    var o = new Object();
    Person.call(o, 'person7', 70, 'a beautifull woman too');
    o.sayName();
</script>

<script>
    var sayName_x = function() { // 自定义的引用类型没有封装性
        console.log(this.name + '-' + this.job)
    };
    function Person_x(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = sayName_x;
    }

    var person8 = new Person_x('person8', 80, 'software engineer');
    var person9 = new Person_x('person9', 90, 'a beautifull woman');
    console.log(person8.sayName(), person9.sayName());
    console.log(person8.sayName, person9.sayName, person8.sayName === person9.sayName);
</script>

<script>
    function Person() { // prototype 调用构造函数创建的那个对象实例的原型对象
    }
    Person.prototype.name = 'person11_person12'; // 可以创建所有 实例共享 的属性，方法
    Person.prototype.age = 30;
    Person.prototype.job = 'job';
    Person.prototype.sayName = function() {
        console.log(this.name + '-' + this.age + '-' + this.job);
    };

    var person11 = new Person();
    var person12 = new Person();
    console.log(person11.sayName, person12.sayName, person11.sayName === person12.sayName);
    console.log('Person.prototype.constructor===============', Person.prototype.constructor, Person, Person.prototype.constructor === Person);
    // 原型对象的属性constructor ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

    // 实例的内部属性 [[Prototype]] __proto__  指向构造函数的原型对象 ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

    // isPrototypeof  原型对象是否是实例的原型
    console.log('isPrototypeOf, ', Person.prototype.isPrototypeOf(person11), Person.prototype.isPrototypeOf(person12));

    // getPrototypeOf  返回实例的原型对象
    console.log('getPrototypeOf, ', Object.getPrototypeOf(person11), Object.getPrototypeOf(person11) === Person.prototype);
    console.log('getPrototypeOf, ', Object.getPrototypeOf(person11).name, Object.getPrototypeOf(person11).age);

    // 先搜索对象实例，再搜索原型  属性
    // 不能通过对象实例重写原型的值
    // delete删除 对象实例 属性 ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    // hasOwnProperty 属性存在 对象实例  ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    person11.name = 'person11';
    console.log('hasOwnProperty, ', person11.name, person11.hasOwnProperty('name'), person12.name, person12.hasOwnProperty('name'));
    delete person11.name;
    console.log(person11.name, person11.hasOwnProperty('name'), person12.name, person12.hasOwnProperty('name'));

    // in  for in 可枚举的对象实例 + 原型 ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    console.log('in for in, ', person11.hasOwnProperty('name'), 'name' in person11);
    person11.name = 'person11';
    console.log(person11.hasOwnProperty('name'), 'name' in person11);

    function hasPrototypeProperty(object, name) { // ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
        return !object.hasOwnProperty(name) && (name in object);
    }
    console.log('hasPrototypeProperty, ', hasPrototypeProperty(person11, 'name'), hasPrototypeProperty(person12, 'name'));
    // 浏览器兼容性 to add

    // Object.keys() 可枚举的实例属性 ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    // Object.getOwnPropertyNames() 所有实例属性 ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    var person13 = new Person();
    person13['name_age'] = 'name_age';
    console.log(Object.keys(person13), Object.keys(Person.prototype));
    console.log(Object.getOwnPropertyNames(person13), Object.getOwnPropertyNames(Person.prototype));  // constructor不可枚举


    function People() {

    }
    console.log('重写整个原型对象之前，', JSON.stringify(People.prototype), People.prototype.constructor); // People
    People.prototype = { // 重写整个原型对象
        // constructor:People, 手动设置 变成可以枚举
        name: 'people_name',
        age: 'people_age',
        job: 'people_job',
        sayName: function() {
            console.log(this.name + '-' + this.age);
        }
    };
    console.log('重写整个原型对象之后，', JSON.stringify(People.prototype), People.prototype.constructor); // Object

    var people = new People();
    people['name_job'] = 'name_job';
    console.log(Object.keys(people), Object.keys(People.prototype));
    console.log(Object.getOwnPropertyNames(people), Object.getOwnPropertyNames(People.prototype));


    // 原型的动态性 ！！！！！！！！！！！！！！！！
    var friend = new People();

    People.prototype.sayHi = function() {
        console.log('sayHi //' + this.name + '//' + this.age + '//' + this.job);
    };
    friend.sayHi();

    // 原型的动态性 ！！！！！！！！！！！！！！！！
    // 重写默认的prototype对象， 1.constructor属性变成了新对象的constructor属性（指向Object构造函数）
    // 2.切断了构造函数与最初原型的联系
    function Person() {

    }
    var friend2 = new Person();

    Person.prototype = {
        constructor: Person,
        name: 'nicholas',
        age: 30,
        friend: 'yc',
        sayHi: function() {
            return 'sayHi //' + this.friend;
        }
    };
    // friend2.sayHi(); error


    // 原生对象的原型
    console.log('native prototype, ', Array.prototype, String.prototype)

    // 原型对象的问题
    // 所有实例在默认情况下都将取得相同的属性值   对于包含引用类型值的属性，问题突出！！！！！！！！！！！！！
    function PeopleF() {

    }

    PeopleF.prototype = {
        constructor: PeopleF,
        name: 'name',
        friends: ['friend1', 'friend2', 'friend3'],
        sayName: function() {
            console.log(this.name + '-' + this.friends.length);
        }
    };
    var peopleF = new PeopleF();
    var peopleF2 = new PeopleF();
    peopleF.friends.push('friend4');
    console.log('原型对象的问题, ', peopleF.friends, peopleF2.friends, peopleF.friends === peopleF2.friends);
    peopleF.sayName();  // 原型对象的重写放在实例化后面就会报错
</script>

<script>
    // 组合使用构造函数模式和原型模式
    function PersonF(name, age, job) { // 实例属性
        this.name = name;
        this.age = age;
        this.job = job;
        this.friends = ['friend1', 'friend2'];
    }

    PersonF.prototype = { // 实例共享的属性
        constructor: PersonF,
        sayName: function() {
            console.log(this.name + '-' + this.friends);
        }
    };

    var personF = new PersonF('yh', 30, 'a beautifull woman');
    var personF2 = new PersonF('yh2', 30, 'a beautifull woman');
    personF.friends.push('friend3');
    console.log('组合使用构造函数模式和原型模式, ', personF.friends, personF2.friends);
    console.log(personF.sayName, personF2.sayName, personF.sayName === personF2.sayName)
</script>

<script>
    // 动态原型模式
    function PersonFD(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;

        if (typeof this.sayName !== 'function') {
            PersonFD.prototype.sayName = function() {
                console.log(this.name + '-' + this.age + '-' + this.job);
            };
        }
    }

    var personFD = new PersonFD('YH', 30, 'LADY');
    personFD.sayName();
</script>


<script>
    // 寄生构造函数模式
    function Person(name, age, job) {
        var o = new Object();
        o.name = name;
        o.age = age;
        o.job = job;
        o.sayJob = function() {
            console.log(this.job);
        };
        return o;
    }
    var friend = new Person('yh', 30, 'a engineer');
    friend.sayJob();

    // 不能直接修改原生对象的构造函数，可以用这个模式
    // 返回的对象与 构造函数，构造函数的原型属性没有关联 不能依赖instanceof来确定对象类型 to add 识别对象类型
    // 不要使用这种模式
    function SpecialArray() {
        var values = new Array();

        values.push.apply(values, arguments);

        values.toPipedString = function() {
            return this.join('|');
        };

        return values;
    }
    var colors = new SpecialArray('red', 'blue', 'green');
    colors.push('xx');
    var colorsJoin = colors.toPipedString();
    console.log(colorsJoin);
    console.log(Object.getPrototypeOf(colors), colors.isPrototypeOf(SpecialArray.prototype));
    console.log(SpecialArray.prototype, SpecialArray.prototype.constructor === SpecialArray);
</script>

<script>
    // 稳妥构造函数模式
    // 没有公共属性，方法不引用this对象
    // 适合在安全环境使用（禁止使用 this，new）；防止数据被其他应用程序改动
    // 与寄生构造函数模式比较，1)新创建对象的实例方法不引用this
    // 2) 不使用new 操作符调用构造函数
    // 适合某些安全执行环境
    function Person(name, age, job) {
        var o = new Object();

        // 定义私有变量和函数

        o.age = age;

        o.sayAge = function() {
            console.log(age);
        };

        return o;
    }

    var friend = new Person('yh', 33, 'a engineer');
    friend.sayAge();


</script>


</body>
</html>