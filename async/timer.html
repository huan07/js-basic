<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        .animation, .change-color {
            width: 400px;
            height: 50px;
        }
    </style>
</head>
<body>
<div class="animation" style="background: pink"></div>

<input type="button" id="my-button" value="click">

<input type="text" class="input-box" value="">

<input type="text" class="input-box fixed" value="立即将字符转为大写">

<div class="change-color"></div>

<div class="change-color fixed"></div>

<script>
    setTimeout(function(a, b){
        console.log(a, b);
    }, 10, '第1个参数', '第2个参数'); // !!

</script>

<script>
    var x = 1;
    var obj = {
        x: 2,
        y: function(){
            console.log(this.x, this);
        }
    };
    setTimeout(obj.y, 10); // 10ms后运行时 this => Window

    // 解决方式1
    setTimeout(function fixed(){
        // 使得obj.y在obj的作用域执行
        obj.y();
    }, 11);

    // 解决方式2
    setTimeout(obj.y.bind(obj), 12);
</script>

<script>
    var animation = document.getElementsByClassName('animation')[0];
    var opacity = 1;
    var fader = setInterval(function(){
        opacity -= 0.01;
        if (opacity >= 0.1) {
            animation.style.opacity = opacity;
        } else {
            clearInterval(fader);
        }
    }, 100);
</script>

<script>
    // setInterval的一个常见用途是实现轮询 to do

</script>

<script>
    // 取消当前所有的setTimeout定时器
    (function(){
        var gid = setInterval(clearAllTimeouts, 0);

        function clearAllTimeouts(){
            var id = setTimeout(function(){

            }, 0);

            for (; id > 0; id--) {
                if (id !== gid) {
                    //clearTimeout(id);
                }
            }
        }
    })();

    // debounce函数   to do
</script>

<script>
    // setTimeout和setInterval的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，
    // 再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。
    // 回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行，传入参数0在下一轮事件循环一开始就执行  ！！

    setInterval(function(){
        console.log(2);
    }, 1000);

    sleep(3000);

    function sleep(ms){
        var start = Date.now();
        if (Date.now() - start === ms) {
            return;
        }
    }
</script>

<script>
    // setTimeout(f, 0)用途
    // 1.可以调整事件的发生顺序。
    var input = document.getElementById('my-button');

    input.onclick = function A(){
        setTimeout(function B(){
            input.value += ' input'; // 子元素的程序后执行
        }, 0);
    };

    document.body.onclick = function C(){
        input.value += ' body';
    };

    // 2.用户自定义的回调函数，通常在浏览器的默认动作之前触发
    document.getElementsByClassName('input-box')[0].onkeypress = function(event){
        this.value = this.value.toUpperCase();
    }

    document.getElementsByClassName('input-box fixed')[0].onkeypress = function(event){
        var self = this;
        setTimeout(function(){
            self.value = self.value.toUpperCase();
        }, 0);
    };

    // 3.将任务放到浏览器最早可得的空闲时段执行，
    // 所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到setTimeout(f, 0)里面执行。
    // 写法1:
    // 会造成浏览器“堵塞”，因为 JavaScript 执行速度远高于 DOM，会造成大量 DOM 操作“堆积”
    var changeColor = document.getElementsByClassName('change-color')[0];
    for (var i = 0x111111; i < 0xffffff; i++) {
        changeColor.style.backgroundColor = '#' + i.toString(16);
    }

    // 写法2: to do
    var changeColorFixed = document.querySelector('.change-color.fixed');
    var timer;
    var i = 0x111111;
    function func(){
        timer = setTimeout(func, 0);
        changeColorFixed.style.backgroundColor = '#' + i.toString(16);
        if (i++ === 0xffffff) {
            clearTimeout(timer);
        }
    }
    timer = setTimeout(func, 0);
</script>


</body>
</html>