<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>6.2.2构造函数模式</title>
</head>
<body>
<script>
    function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function() { // 每个方法都要在每个实例上重新创建一遍，（完成的是相同的任务，没有必要待改进）
            console.log(this.name + '-' + this.age);
        };
    }

    var person = new Person('person', 30, 'software engineer');
    var person2 = new Person('person2', 40, 'a beautifull woman');
    person.sayName();
    person2.sayName();
    console.log(person.sayName, person2.sayName, person.sayName === person2.sayName);  // 问题：不同实例上的同名函数是不相等的！！！！！！！！

    // new 操作法 经历的4个步骤！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    //（1）创建一个新对象
    //（2）将构造函数的作用域赋给新对象（this指向这个新对象）
    //（3）执行构造函数的代码（为新对象添加属性）
    //（4）返回新对象

    console.log('对象实例constructor属性========', person.constructor, Person, person.constructor === Person);

    console.log(person instanceof Object, person instanceof Person, person2 instanceof Object, person2 instanceof Person);

    // 构造函数与普通函数的区别：调用方式不一样

    // Person的调用方式！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！call
    // 1.
    var person = new Person('person5', 50, 'a beautifull woman');
    person.sayName();

    // 2.
    Person('person6', 60, 'a beautifull woman too'); // 添加到Window
    window.sayName();

    // 3. 在另一个对象的作用域中调用！！！！！！！！！！！！！！！！！！！！！！！
    var o = new Object();
    Person.call(o, 'person7', 70, 'a beautifull woman too');
    o.sayName();
</script>

<script>
    var sayName = function() { // 指向函数的指针 被person1、person2对象共享   但是作为全局函数不合适
        console.log(this.name + '-' + this.job)
    };
    function Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = sayName;
    }

    var person1 = new Person('person1', 80, 'software engineer');
    var person2 = new Person('person9', 90, 'a beautifull woman');
    console.log(person1.sayName(), person2.sayName());
    console.log(person2.sayName, person2.sayName, person1.sayName === person2.sayName);
</script>

</body>
</html>