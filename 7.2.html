<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>7.2</title>
</head>
<body>
<script>
    // 闭包：有权访问另一个函数作用域中的变量的函数（用途1）
    // 闭包实现方式：一个函数内部创建另一个函数

    // 调用函数时，创建它的执行环境（后台会有表示变量的对象－变量对象）及作用域链
    // 函数执行完毕后，局部活动对象被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）

    // 闭包情况：在另一个函数内部定义的函数 会将包含函数（外部函数）的活动对象添加到它的作用域链中
    // 闭包的问题：闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存

    // 闭包优点／缺点：可以把局部变量驻留在内存中，可以避免使用全局变量，
    function createComparisonFunction(propertyName){

        return function(object1, object2){  // 匿名函数当作值返回
            var value1 = object1[propertyName];  //
            var value2 = object2[propertyName]; // 访问了createComparisonFunction的变量propertyName

            if (value1 < value2) {
                return -1;
            } else if (value1 > value2) {
                return 1;
            } else {
                return 0;
            }
        }
    }

    var compareNames = createComparisonFunction('name');
    console.log(compareNames);
    var result = compareNames({ name: 'yh1' }, { name: 'yh2' });
    console.log(result);


    compareNames = null; // 解除对匿名函数的引用（以便释放内存, 外层函数的活动对象被销毁）
</script>

<script>
    // 作用域链的副作用：闭包只能取得包含函数中任何变量的最后一个值（用途2，但会带来副作用）

    function createFunction(){
        var result = new Array();

        for (var i = 0; i < 10; i++) {
            result[i] = function(){ // ....
                return i;
            }; // .....
        }

        return result;
    }

    console.log('createFunction', createFunction());
    console.log(createFunction()[0]());
    console.log(createFunction()[9]());

    function createFunction2(){
        var result = new Array();

        for (var i = 0; i < 10; i++) {
            result[i] = function(num){ // 创建另一个匿名函数  高级了!!!!!!!!!!!!!!!!!!!!!!!!!!
                return function(){ // 闭包
                    return num;
                };
            }(i); // .....................
        }

        return result;
    }
    console.log('createFunction2', createFunction2());
    console.log(createFunction2()[0]());
    console.log(createFunction2()[9]());

    // 闭包的 this对象
    // 匿名函数的执行环境具有全局性，this指向的是 window
    var name = "The Window";
    var object = {
        name: "The Object",

        getNameFunc: function(){
            return function(){
                return this.name;
            }
        }
    };
    console.log('返回匿名函数', object.getNameFunc());
    console.log(object.getNameFunc()());

    var name = "The Window";
    var object2 = {
        name: "The Object2",
        getNameFunc: function(){
            var that = this;
            return function(){
                return that.name;
            }
        }
    };
    console.log('返回匿名函数2', object2.getNameFunc());
    console.log(object2.getNameFunc()());

    var object3 = {
        name: "The Object3",
        getName: function(){
            return this.name;
        }
    }
    console.log(object3.getName());
    console.log((object3.getName)());
    // 第三种方式 to add


    // 内存泄露 ?  ?  ?   ?  ?   ?  ?    ?   ?    ?   ?    ?


</script>
<script>
    // 练习题
    function a(){
        var i = 0;

        function b(){
            console.log(++i);
        }

        return b;
    }
    var c = a();
    c();  // 1

    // 练习题2
    function f1(){
        var n = 999;
        nAdd = function(){
            n = n + 1;
        };
        function f2(){
            console.log(n);
        }

        return f2;
    }
    var rs = f1();
    rs();   // 999;
    nAdd();
    rs(); // 1000  n 一直保存在内存中

    // 练习题3
    var a = 111;
    function test(){
        console.log(a); // undefined
        var a = 11;

        function subTest(){
            console.log(a); // 11
        }

        return subTest;
    }
    test()();
</script>

</body>
</html>