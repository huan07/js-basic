<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>7.2</title>
</head>
<body>
<script>
    // 闭包：有权访问另一个函数作用域中的变量的函数
    // 闭包实现方式：一个函数内部创建另一个函数
    // 变量对象
    // 一般情况，当函数执行完毕后，局部活动对象被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）
    // 闭包情况：在另一个函数内部定义的函数 会将包含函数（外部函数）的活动对象添加到它的作用域链中
    // 闭包的问题：闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存
    function createComparisonFunction(propertyName) {

        return function(object1, object2) {  // 匿名函数当作值返回
            var value1 = object1[propertyName];  //
            var value2 = object2[propertyName]; // 访问了createComparisonFunction的变量propertyName

            if (value1 < value2) {
                return -1;
            } else if (value1 > value2) {
                return 1;
            } else {
                return 0;
            }
        }

    }

    var compareNames = createComparisonFunction('name');
    console.log(compareNames);
    var result = compareNames({ name: 'yh1' }, { name: 'yh2' });
    console.log(result);

    compareNames = null; // 解除对匿名函数的引用（以便释放内存）
</script>

<script>
    // 作用域链的副作用：闭包只能取得包含函数中任何变量的最后一个值

    function createFunction() {
        var result = new Array();

        for(var i = 0; i < 10; i++) {
            result[i] = function() { // ....
                return i;
            }; // .....
        }

        return result;
    }

    console.log(createFunction());
    console.log(createFunction()[0]());
    console.log(createFunction()[9]());

    function createFunction2() {
        var result = new Array();

        for(var i = 0; i < 10; i++) {
            result[i] = function(num) { // 创建另一个匿名函数  高级了!!!!!!!!!!!!!!!!!!!!!!!!!!
                return function() { // 闭包
                    return num;
                };
            }(i); // .....................
        }

        return result;
    }
    console.log(createFunction2());
    console.log(createFunction2()[0]());
    console.log(createFunction2()[9]());

    // 闭包的 this对象
    // 匿名函数的执行环境具有全局性，this指向的是 window
    var name = "The Window";
    var object = {
        name: "The Object",

        getNameFunc: function() {
            return function() {
                return this.name;
            }
        }
    };
    console.log(object.getNameFunc());
    console.log(object.getNameFunc()());

    var name = "The Window";
    var object2 = {
        name: "The Object2",
        getNameFunc: function() {
            var that = this;
            return function() {
                return that.name;
            }
        }
    };
    console.log(object2.getNameFunc());
    console.log(object2.getNameFunc()());

    var object3 = {
        name: "The Object3",
        getName: function() {
            return this.name;
        }
    }
    console.log(object3.getName());
    console.log((object3.getName)());
    // 第三种方式 to add


    // 内存泄露 ?  ?  ?   ?  ?   ?  ?    ?   ?    ?   ?    ?


</script>

</body>
</html>