<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>5.5</title>
</head>
<body>

<script>
    console.log('每个 函数 都是Function类型的 实例，函数名 是一个指向函数对象的 指针（变量）');
    console.log('函数是对象，函数名是指针');

    function sum(num1, num2) {
        return num1 + num2;
    }
    console.log(sum(10, 20));
    console.log(sum.length, sum, sum.prototype, sum.prototype.constructor === sum);

    var anotherSum = sum;// 访问函数指针，非调用！！！！！！！！！！！！！！！！！！！！！！
    console.log(anotherSum(10, 20));

    sum = null;
    //console.log(sum(10,20)); // error
    console.log(anotherSum(100, 200));
</script>


<script>
    console.log('函数声明 函数表达式区别');
    console.log('1:解析器', 'js引擎会将  函数声明  提升到作用域的顶部'); // 将var function关键字提升到作用域最前面
    // 唯一区别
    console.log('函数表达式 按一般var变量的方式执行');

    // 练习题
    console.log(fn);   // f fn(){}     ！！！！！！！！！！！！！
    function fn() {

    }

    console.log(fn2);  // undefined     ！！！！！！！！！！！！！
    // console.log(fn2()); // error
    var fn2 = function() {

    };

    var name = 'xm';
    var age = 18;
    function fun() {
        var name = 'xh';
        var age = 10;
        console.log(name);  // 'xh'
    }
    fun();


    var name = 'xml';
    var age = 181;
    function fun2() {
        console.log(name);  // undefined
        var name = 'xh';
        var age = 10;
    }
    fun2();
</script>


<script>
    // 1.函数作为参数==============
    // 2.函数作为返回值=====匿名函数===========

    function callSomeFunction(someFunction, someArgument) {
        return someFunction(someArgument);
    }
    function getGreeting(name) {
        return "Hello," + name;
    }
    console.log('callSomeFunction(getGreeting=   ', callSomeFunction(getGreeting, 'yh'));

    function createComparisonFunction(propertyName) {
        return function(obj1, obj2) {
            var value1 = obj1[propertyName];
            var value2 = obj2[propertyName];
            return value1 - value2; // 升序
        }
    }
    var personArray = [
        {
            name: 11,
            age: 23
        },
        {
            name: 12,
            age: 22
        },
        {
            name: 13,
            age: 21
        }
    ];
    personArray.sort(createComparisonFunction('age'));
    console.log('personArray=   ', personArray);
</script>

<script>
    // 函数内部属性 arguments,this======================
    // arguments.callee 指向拥有arguments对象的函数===============
    function factorial(num) {
        if (num <= 1) {
            return 1;
        } else {
            return num * arguments.callee(num - 1); // 严格模式会报错
        }
    }
    console.log(factorial(5));

    var trueFactorial = factorial;
    factorial = function() {
        return 0;
    };
    console.log(trueFactorial(3), factorial(3));
</script>

<script>
    // this 函数据以执行的环境对象========================
    window.color = "red";
    var o = { color: "blue" };

    function sayColor() {
        console.log(this.color);
    }

    sayColor();

    o.sayColor = sayColor;
    o.sayColor();
</script>

<script>
    // caller to add
    // callee to add

</script>

<script>
    // sum.prototype.constructor===sum
    // 非继承方法  call apply (接受参数不一样) 没有参数传递的情况，用法一样
    // 1.用来传递参数
    // 2.扩充函数赖以运行的作用域, 优点：对象不需要和方法有任何耦合
    // bind this值会被绑定到bind的第一个参数，

    // 1.
    function sum(num1, num2) {
        return num1 + num2;
    }

    function applySum1(num1, num2) {
        return sum.apply(this, arguments);
    }

    function applySum2(num1, num2) {
        return sum.apply(this, [num1, num2]);
    }

    function callSum(num1, num2) {
        return sum.call(this, num1, num2);
    }
    console.log(applySum1(11, 22), applySum2(22, 33), callSum(33, 44))

    // 2.
    window.color = "windowColor";
    var o = { color: "oColor" };

    function sayColor() {
        console.log(this, this.color);
    }

    sayColor.apply(window);
    sayColor.apply(this);  // 严格模式下  this是undefined
    sayColor.apply(o);

    sayColor.call(window);
    sayColor.call(this);
    sayColor.call(o);

    var windowSayColor = sayColor.bind(window);
    var oSayColor = sayColor.bind(o);
    windowSayColor();
    oSayColor();
</script>

</body>
</html>