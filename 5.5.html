<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>5.5</title>
</head>
<body>

<script>
    console.log('每个函数都是Function类型的实例，函数名是一个指向函数对象的指针（变量）  没有重载');

    function sum(num1, num2) {
        return num1 + num2;
    }
    console.log(sum(10, 20));

    var anotherSum = sum;
    console.log(anotherSum(10, 20));

    sum = null;
    //console.log(sum(10,20)); // error
    console.log(anotherSum(10, 20));
</script>

<script>
    console.log('函数声明 函数表达式区别');
    console.log('1:解析器');

    console.log('在执行任何代码前解析器先读取函数声明；执行到函数表达式，才执行');

    console.log('2:');
    console.log('函数声明 函数表达式区别');

</script>

<script>
    function callSomeFunction(someFunction, someArgument) {
        return someFunction(someArgument);
    }
    function getGreeting(name) {
        return "Hello," + name;
    }
    console.log('1.函数作为参数==============', callSomeFunction(getGreeting, 'yh'));


    function createComparisonFunction(propertyName) {
        return function(obj1, obj2) {
            var value1 = obj1[propertyName];
            var value2 = obj2[propertyName];
            return value1 - value2; // 升序
        }
    }
    var personArray = [
        {
            name: 11,
            age: 13
        },
        {
            name: 12,
            age: 12
        },
        {
            name: 13,
            age: 11
        }
    ];
    personArray.sort(createComparisonFunction('name'));
    // 比较顺序
    // 1>2
    // 2>3
    console.log('2.函数作为返回值================', personArray);
</script>

<script>
    console.log('函数内部属性 arguments,this======================');
    console.log('arguments.callee 指向当前执行的函数===============')

    function factorial(num) {
        if (num <= 1) {
            return 1;
        } else {
            return num * arguments.callee(num - 1);
        }
    }
    console.log(factorial(5))

    var trueFactorial = factorial;
    factorial = function() {
        return 0;
    };
    console.log(trueFactorial(3), factorial(3));
</script>

<script>
    console.log('this 函数据以执行的环境对象========================');
    window.color = "red";
    var o = { color: "blue" };

    function sayColor() {
        console.log(this.color);
    }

    sayColor();

    o.sayColor = sayColor;
    o.sayColor();
</script>

<script>
    console.log('prototype================= 非继承方法  call apply ================');
    console.log('1.传递参数；  2.扩充函数赖以运行的作用域,优点：对象不需要和方法有任何耦合')

    // 1.
    function sum(num1, num2) {
        return num1 + num2;
    }

    function applySum1(num1, num2) {
        return sum.apply(this, arguments);
    }

    function applySum2(num1, num2) {
        return sum.apply(this, [num1, num2]);
    }

    function callSum(num1, num2) {
        return sum.call(this, num1, num2);

    }

    console.log('apply两种传参数＝＝＝＝＝', applySum1(11, 22), applySum2(22, 33));
    console.log('call将传参数一一罗列出来＝＝＝＝＝', callSum(33, 44))

    // 2.
    window.color = "red1";
    var o = { color: "blue1" };

    function sayColor() {
        console.log(this, this.color);
    }

    sayColor.apply(window);
    sayColor.apply(this);
    sayColor.apply(o);

    sayColor.call(window);
    sayColor.call(this);
    sayColor.call(o);
</script>

<script>
    console.log('bind==================================================');
    window.color = "red2";
    var o = {
        color: "blue2"
    };

    function sayColor() {
        console.log(this.color);
    }
    var windowSayColor = sayColor.bind(window);
    var oSayColor = sayColor.bind(o);
    windowSayColor();
    oSayColor();


    function sayColorxxx(xxx) {
        console.log(this.color + xxx);
    }
    var windowSayColorxxx = sayColorxxx.bind(window);
    var oSayColorxxx = sayColorxxx.bind(o);
    windowSayColorxxx('window');
    oSayColorxxx('o');
</script>

</body>
</html>