<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>5.5</title>
</head>
<body>

<script>
    // 每个 函数 都是Function类型的 实例，函数名 是一个指向函数对象的 指针（变量）
    // 函数是对象，函数名是指针

    function sum(num1, num2){
        return num1 + num2;
    }
    console.log(sum(10, 20));
    console.log(sum.length, sum, sum.prototype, sum.prototype.constructor === sum);

    var anotherSum = sum;// 访问函数指针，非调用！！！！！！！！！！！！！！！！！！！！！！
    console.log(anotherSum(10, 20));

    sum = null;
    //console.log(sum(10,20)); // error
    console.log(anotherSum(100, 200));
</script>

<script>
    // 函数声明 函数表达式区别
    // 唯一区别
    // 1.解析器将  函数声明  变量声明  提升到作用域的顶部
    // 2.函数表达式 按一般var变量的方式执行


    // 考题1
    console.log(fn);   // f fn(){}     ！！！！！！！！！！！！！
    function fn(){

    }

    console.log(fn2);  // undefined     ！！！！！！！！！！！！！
    // console.log(fn2()); // error
    var fn2 = function(){

    };

    // 考题2
    var name = 'xm';
    var age = 18;
    function fun(){
        var name = 'xh';
        var age = 10;
        console.log(name);  // 'xh'
    }
    fun();

    var name = 'xml';
    var age = 181;
    function fun2(){
        console.log(name);  // undefined
        var name = 'xh';
        var age = 10;
    }
    fun2();
</script>

<script>
    // 1.函数作为参数
    // 2.函数作为返回值 匿名函数

    function callSomeFunction(someFunction, someArgument){
        return someFunction(someArgument);
    }
    function getGreeting(name){
        return "Hello," + name;
    }
    console.log('函数作为参数 => ', callSomeFunction(getGreeting, 'yh'));

    function createComparisonFunction(propertyName){
        return function(obj1, obj2){
            var value1 = obj1[propertyName];
            var value2 = obj2[propertyName];

            if (value1 < value2) {
                return -1;
            } else if (value1 > value2) {
                return 1;
            } else {
                return 0;
            }
        };
    }
    var personArray = [
        {
            name: 'yh',
            age: 23
        },
        {
            name: 'ym',
            age: 22
        },
        {
            name: 'xh',
            age: 21
        }
    ];
    personArray.sort(createComparisonFunction('name'));
    console.log('函数作为返回值 => ', personArray);
</script>

<script>
    // 函数内部属性 arguments,this
    // arguments.callee 指向拥有arguments对象的函数
    function factorial(num){
        if (num <= 1) {
            return 1;
        } else {
            return num * arguments.callee(num - 1); // 严格模式会报错
        }
    }
    console.log(factorial(5));

    var trueFactorial = factorial;
    factorial = function(){
        return 0;
    };
    console.log(trueFactorial(5), factorial(5));
</script>

<script>
    // this 函数据以执行的环境对象
    window.color = "red";
    var o = { color: "blue" };

    function sayColor(){
        console.log('this =>', this.color);
    }

    sayColor();

    o.sayColor = sayColor;
    o.sayColor();
</script>

<script>
    // caller

</script>

<script>
    // sum.prototype.constructor === sum
    // 非继承方法call,apply  特定的作用域调用函数； 接受参数不一样，没有参数传递的情况，用法一样
    // 1.用来传递参数
    // 2.扩充函数赖以运行的作用域, 优点：对象不需要和方法有任何耦合
    // bind this值会被绑定到bind的第一个参数，

    // 1. 函数的间接调用
    function sum(num1, num2){
        return num1 + num2;
    }

    function applySum(num1, num2){
        return sum.apply(this, arguments);
    }

    function applySum2(num1, num2){  // 使用场景：传一个参数，并且是数组类型的数据
        return sum.apply(this, [num1, num2]);
    }

    function callSum(num1, num2){
        return sum.call(this, num1, num2);
    }
    console.log(applySum(11, 22), applySum2(22, 33), callSum(33, 44));

    // 2.
    window.color = "windowColor";
    var o = { color: "oColor" };

    function sayColor(){
        console.log(this.color);
    }
    sayColor.apply(this);
    sayColor.apply(window);
    sayColor.apply(o);

    sayColor.call(this);
    sayColor.call(window);
    sayColor.call(o);

    var windowSayColor = sayColor.bind(window);
    windowSayColor();

    var oSayColor = sayColor.bind(o);
    oSayColor();
</script>

</body>
</html>